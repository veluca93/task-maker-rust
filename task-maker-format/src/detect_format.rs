use std::path::PathBuf;

use anyhow::{anyhow, bail, Context, Result};

use crate::{ioi, terry, EvaluationConfig, TaskFormat};

/// Search for a valid task directory, starting from base and going _at most_ `max_depth` times up.
pub fn find_task<P: Into<PathBuf>>(
    base: P,
    max_depth: u32,
    eval_config: &EvaluationConfig,
) -> Result<Box<dyn TaskFormat>> {
    let mut base = base.into();
    if !base.is_absolute() {
        base = getcwd().join(base);
    }
    let mut fails = vec![];
    for _ in 0..max_depth {
        let mut task: Option<Box<dyn TaskFormat>> = None;
        // try to parse a IOI task
        if ioi::IOITask::is_valid(&base) {
            match ioi::IOITask::new(&base, eval_config) {
                Ok(ioi_task) => task = Some(Box::new(ioi_task)),
                Err(err) => fails.push(("IOI", base.clone(), err)),
            }
        }
        // try to parse a Terry task
        if terry::TerryTask::is_valid(&base) {
            match terry::TerryTask::new(&base, eval_config) {
                Ok(terry_task) => {
                    if task.is_some() {
                        bail!("Ambiguous task directory, can be either IOI and terry")
                    }
                    task = Some(Box::new(terry_task))
                }
                Err(err) => fails.push(("Terry", base.clone(), err)),
            }
        }
        // if a task is found, return it
        if let Some(task) = task {
            return Ok(task);
        }
        // not task found yet, try on the parent folder
        base = match base.parent() {
            Some(parent) => parent.into(),
            _ => break,
        };
    }

    let mut message = "\n".to_string();
    for (format, path, error) in fails {
        message += &format!("    - Not a valid {} task at {}\n", format, path.display());
        error
            .chain()
            .for_each(|cause| message += &format!("      Caused by:\n        {}\n", cause));
    }

    Err(anyhow!("{}", message)).context("Cannot find a valid task directory")
}

/// Return the current working directory.
///
/// `std::env::current_dir()` resolves the symlinks of the cwd's hierarchy, `$PWD` is used instead.
fn getcwd() -> PathBuf {
    std::env::var("PWD")
        .map(PathBuf::from)
        .unwrap_or_else(|_| std::env::current_dir().expect("Cannot get current working directory"))
}
